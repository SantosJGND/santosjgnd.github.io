---
layout: post
title: "Deepcopy - Locks"
date: 2023-06-17 10:23:29 +0000
categories: python development deepcopy
use_math: true
---

Writting this post about a recent problem i had with deepcopy, and how i solved it. 

NOTE: this post addresses an issue with the `logging` python package that was solved in version `3.7`, so if you do not find yourself under a similar constraint, it won't have practical value.

### The problem

Working on a project that involved generating copies of a complex class. Specifically, instances of this class correspond to nodes in 
a self-generating directed graph -> a tree. Starting at the root, at each generation the tree generates a new layer of nodes from existing leaves,
leaves are given new ids and settings, after which they are submitted (or logged) and the process repeats. e.g.:

``` python
    def update_nodes(self):
        new_nodes = []
        for node in self.current_nodes:
            children = node.children
            for child in children:
                new_node = self.spawn_node_child(node, child)
                new_nodes.append(new_node)
```

where `spawn_node_child` is a method that generates a new node from an existing node and a child id. The new node is then added to the list of current nodes, and the process repeats.

``` python
    def spawn_node_child(self, node: Tree_Node, child: int):
        new_node = Tree_Node(self.tree, child, node.software_tree_pk)
        run_manager_copy = copy.deepcopy(node.run_manager)
        new_node.receive_run_manager(run_manager_copy)
        new_node.run_manager.update_engine()

        return new_node
```

Here, nodes are complex classes that are already two layers of abstraction detatched from an analysis engine which they help manage the deployment of and the logging of results from. Copying allows us to keep track of the state of the tree at each generation, and to compare the results of different runs.

The problem is that many of the major classes involved contain loggers, which include locks to prevent multiple threads from writing to the same file at the same time. The `deepcopy` function will try to copy the locks and break. 

### Deepcoy

So, deepcopy has runs a series of checks on the object to copy, one of which relies on a dictionary, `_copy_dispatch`, that maps the object type to a series of pre-defined functions for specific cases:

``` python
_copy_dispatch = d = {}



def _copy_immutable(x):
    return x


for t in (
    type(None),
    int,
    float,
    bool,
   ...
    property,
    types.BuiltinFunctionType,
    type(Ellipsis),
    type(NotImplemented),
    types.FunctionType,
    weakref.ref,
):
    d[t] = _copy_immutable
t = getattr(types, "CodeType", None)
if t is not None:
    d[t] = _copy_immutable

d[list] = list.copy

```
The most common of these pre-defined functions is `_copy_immutable`, which simply returns the object. This is the case for most of the objects in the tree, but not for the loggers.


### The solution

The solution is to add a new entry for logging.Logger to the `_copy_dispatch` dictionary that will return the same object without attempting to copy. This is done by adding the following code to the `__init__.py` file of the project:

``` python

from copy import _copy_immutable, _deepcopy_dispatch
import logging
def logger_copy(x, memo):
    return x


copy._deepcopy_dispatch[logging.Logger] = logger_copy
```

### The result

The result is that the deepcopy function will now ignore the locks and copy the loggers. This is not a problem because, at least in this case, i wanted the loggers to continue to write to the same file.

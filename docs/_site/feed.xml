<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-07-19T18:41:38+01:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Research Log</title><subtitle>A technical account of my research path where I expose the problems I faced and how I solved them, with some detours into interesting tangents along the way.
</subtitle><author><name>SantosJGND</name><email>dourado.jns@gmail.com</email></author><entry><title type="html">Bionformatics, Matrix Multiplication and Hash Tables</title><link href="http://localhost:4000/bioinformatics/matrix-multiplication/hash-tables/counting/2023/07/19/bioinformatics-counts.html" rel="alternate" type="text/html" title="Bionformatics, Matrix Multiplication and Hash Tables" /><published>2023-07-19T00:34:26+01:00</published><updated>2023-07-19T00:34:26+01:00</updated><id>http://localhost:4000/bioinformatics/matrix-multiplication/hash-tables/counting/2023/07/19/bioinformatics-counts</id><content type="html" xml:base="http://localhost:4000/bioinformatics/matrix-multiplication/hash-tables/counting/2023/07/19/bioinformatics-counts.html"><![CDATA[<p>A common problem in bioinformatics is to count the number of times a sequence appears in a genome. For example, you might want to know how many times the sequence <code class="language-plaintext highlighter-rouge">ATG</code> appears in the genome of a given organism. This is a simple problem, but it can be computationally expensive. The genome of a bacteria can be millions of base pairs long, and the sequence you are looking for can be of any length. So how do you solve this problem efficiently?</p>

<h3 id="constructing-profiles">Constructing profiles</h3>

<p>Lets begin by how we record profiles - think of a record of the presence / absence of set of patterns in a given sequence. For example, for the sorted set <code class="language-plaintext highlighter-rouge">[A, T, C, G]</code>, we can represent the letter pattern <code class="language-plaintext highlighter-rouge">A</code> as <code class="language-plaintext highlighter-rouge">[1, 0, 0, 0]</code>, the letter pattern <code class="language-plaintext highlighter-rouge">T</code> as <code class="language-plaintext highlighter-rouge">[0, 1, 0, 0]</code>, and so on. We can then represent the sequence <code class="language-plaintext highlighter-rouge">ATG</code> as <code class="language-plaintext highlighter-rouge">[[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 0, 1]]</code>.</p>

<p>You may be tempted to generate these profiles using membership tests, as follows:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">pattern</span><span class="o">=</span> <span class="p">[</span><span class="s">"A"</span><span class="p">]</span>
<span class="n">sorted_set</span> <span class="o">=</span> <span class="p">[</span><span class="s">"A"</span><span class="p">,</span> <span class="s">"T"</span><span class="p">,</span> <span class="s">"C"</span><span class="p">,</span> <span class="s">"G"</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">count_patterns</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">sorted_set</span><span class="p">):</span>
    
    <span class="k">return</span> <span class="p">[</span><span class="mi">1</span> <span class="k">if</span> <span class="n">letter</span> <span class="ow">in</span> <span class="n">pattern</span> <span class="k">else</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">letter</span> <span class="ow">in</span> <span class="n">sorted_set</span><span class="p">]</span>
    </code></pre></figure>

<p>But this is not efficient. The <code class="language-plaintext highlighter-rouge">in</code> operator will loop through the entire sequence, and for every element in the sequence it will loop through the entire pattern.</p>

<p>Alternatively, we can use hash-tables (dictionaries in python):</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">pattern</span><span class="o">=</span> <span class="p">{</span><span class="s">"A"</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span>
<span class="n">sorted_set</span> <span class="o">=</span> <span class="p">[</span><span class="s">"A"</span><span class="p">,</span> <span class="s">"T"</span><span class="p">,</span> <span class="s">"C"</span><span class="p">,</span> <span class="s">"G"</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">count_patterns</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">sorted_set</span><span class="p">):</span>
    
    <span class="k">return</span> <span class="p">[</span>
        <span class="n">pattern</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="n">letter</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">letter</span> <span class="ow">in</span> <span class="n">sorted_set</span>
    <span class="p">]</span>
    </code></pre></figure>

<p>This is more efficient. The <code class="language-plaintext highlighter-rouge">get</code> method of dictionaries has a time complexity of <code class="language-plaintext highlighter-rouge">O(1)</code>, so this will be faster than the membership test. The difference is not noticeable for small sequences, but it becomes noticeable for large sequences. Counting could be done with small modifications.</p>

<h3 id="counting-shared-occurrences">Counting shared occurrences</h3>

<p>The naive approach is to loop through the sequence, and for every position in the sequence, check if the pattern appears in another. This is not efficient. For a sequence of length <code class="language-plaintext highlighter-rouge">n</code>, and a pattern of length <code class="language-plaintext highlighter-rouge">k</code>, this has a time complexity of <code class="language-plaintext highlighter-rouge">O(nk)</code>.</p>

<p>Lets try to solve this problem using matrix multiplication. Let’s say we have constructed a list of profiles,</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">profiles</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="p">]</span></code></pre></figure>

<p>And we wish to create a matrix of shared occurrences. We can do this by multiplying the transpose of the profiles with the profiles themselves, with the resulting product:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">product</span><span class="o">=</span> <span class="p">[</span>
    <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="p">]</span></code></pre></figure>

<p>where the diagonal will represent the sum of patterns in each profile, and the off-diagonal elements will represent the number of shared occurrences between profiles.</p>

<p>this is easy in python using the numpy package:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">profiles</span><span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span>
    <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="p">])</span>


<span class="n">product</span> <span class="o">=</span> <span class="n">profiles</span> <span class="o">@</span> <span class="n">profiles</span><span class="p">.</span><span class="n">T</span></code></pre></figure>

<p>The time complexity of matrix multiplication is <code class="language-plaintext highlighter-rouge">O(n^2.373)</code>, relative to simple count: <code class="language-plaintext highlighter-rouge">O(nk)</code>.</p>

<p>This is more efficient for unbalanced datasets. This is common in biological datasets where the number of features (e.g. markers) is generally much larger than the number of samples.</p>

<h3 id="very-large-matrices">very large matrices</h3>

<p>While matrix multiplication is efficient, it is not practical to keep entire matrices in memory. The solution is to split these operations into chunks, e.g.:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">chunk_matrix</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">chunk_size</span><span class="p">):</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">matrix</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">chunk_size</span><span class="p">):</span>
        <span class="k">yield</span> <span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="n">chunk_size</span><span class="p">,</span> <span class="p">:]</span>


<span class="k">for</span> <span class="n">chunk</span> <span class="ow">in</span> <span class="nf">chunk_matrix</span><span class="p">(</span><span class="n">profiles</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>

    <span class="n">subset_product</span><span class="o">=</span> <span class="n">chunk</span> <span class="o">@</span> <span class="n">profiles</span><span class="p">.</span><span class="n">T</span>

    <span class="c1">## do something with subset_product</span></code></pre></figure>

<h1 id="conclusion">Conclusion</h1>

<p>This is a simple idea with many applications. I have used it to extract the mutation spectrum in primates [1], more recently to study patterns of cross-mapping in metagenomics [2]. It could be useful to apply to VCF files to study patterns of variation in populations.</p>

<p>[1] <a href="https://doi.org/10.1093/gbe/evad019">https://doi.org/10.1093/gbe/evad019</a></p>

<p>[2] <a href="https://insaflu.insa.pt/">https://insaflu.insa.pt/</a></p>]]></content><author><name>SantosJGND</name><email>dourado.jns@gmail.com</email></author><category term="bioinformatics" /><category term="matrix-multiplication" /><category term="hash-tables" /><category term="counting" /><summary type="html"><![CDATA[A common problem in bioinformatics is to count the number of times a sequence appears in a genome. For example, you might want to know how many times the sequence ATG appears in the genome of a given organism. This is a simple problem, but it can be computationally expensive. The genome of a bacteria can be millions of base pairs long, and the sequence you are looking for can be of any length. So how do you solve this problem efficiently?]]></summary></entry><entry><title type="html">Deepcopy - Locks</title><link href="http://localhost:4000/python/development/deepcopy/2023/06/17/deepcopy.html" rel="alternate" type="text/html" title="Deepcopy - Locks" /><published>2023-06-17T11:23:29+01:00</published><updated>2023-06-17T11:23:29+01:00</updated><id>http://localhost:4000/python/development/deepcopy/2023/06/17/deepcopy</id><content type="html" xml:base="http://localhost:4000/python/development/deepcopy/2023/06/17/deepcopy.html"><![CDATA[<p>Writting this post about a recent problem i had with deepcopy, and how i solved it.</p>

<p>NOTE: this post addresses an issue with the <code class="language-plaintext highlighter-rouge">logging</code> python package that was solved in version <code class="language-plaintext highlighter-rouge">3.7</code>, so if you do not find yourself under a similar constraint, it won’t have practical value.</p>

<h3 id="the-problem">The problem</h3>

<p>Working on a project that involved generating copies of a complex class. Specifically, instances of this class correspond to nodes in 
a self-generating directed graph -&gt; a tree. Starting at the root, at each generation the tree generates a new layer of nodes from existing leaves,
leaves are given new ids and settings, after which they are submitted (or logged) and the process repeats. e.g.:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">def</span> <span class="nf">update_nodes</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">new_nodes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">current_nodes</span><span class="p">:</span>
            <span class="n">children</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">children</span>
            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">children</span><span class="p">:</span>
                <span class="n">new_node</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">spawn_node_child</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">child</span><span class="p">)</span>
                <span class="n">new_nodes</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">new_node</span><span class="p">)</span>
</code></pre></div></div>

<p>where <code class="language-plaintext highlighter-rouge">spawn_node_child</code> is a method that generates a new node from an existing node and a child id. The new node is then added to the list of current nodes, and the process repeats.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">def</span> <span class="nf">spawn_node_child</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">Tree_Node</span><span class="p">,</span> <span class="n">child</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">new_node</span> <span class="o">=</span> <span class="nc">Tree_Node</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">tree</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="n">node</span><span class="p">.</span><span class="n">software_tree_pk</span><span class="p">)</span>
        <span class="n">run_manager_copy</span> <span class="o">=</span> <span class="n">copy</span><span class="p">.</span><span class="nf">deepcopy</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">run_manager</span><span class="p">)</span>
        <span class="n">new_node</span><span class="p">.</span><span class="nf">receive_run_manager</span><span class="p">(</span><span class="n">run_manager_copy</span><span class="p">)</span>
        <span class="n">new_node</span><span class="p">.</span><span class="n">run_manager</span><span class="p">.</span><span class="nf">update_engine</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">new_node</span>
</code></pre></div></div>

<p>Here, nodes are complex classes that are already two layers of abstraction detatched from an analysis engine which they help manage the deployment of and the logging of results from. Copying allows us to keep track of the state of the tree at each generation, and to compare the results of different runs.</p>

<p>The problem is that many of the major classes involved contain loggers, which include locks to prevent multiple threads from writing to the same file at the same time. The <code class="language-plaintext highlighter-rouge">deepcopy</code> function will try to copy the locks and break.</p>

<h3 id="deepcoy">Deepcoy</h3>

<p>So, deepcopy has runs a series of checks on the object to copy, one of which relies on a dictionary, <code class="language-plaintext highlighter-rouge">_copy_dispatch</code>, that maps the object type to a series of pre-defined functions for specific cases:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">_copy_dispatch</span> <span class="o">=</span> <span class="n">d</span> <span class="o">=</span> <span class="p">{}</span>



<span class="k">def</span> <span class="nf">_copy_immutable</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span>


<span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="p">(</span>
    <span class="nf">type</span><span class="p">(</span><span class="bp">None</span><span class="p">),</span>
    <span class="nb">int</span><span class="p">,</span>
    <span class="nb">float</span><span class="p">,</span>
    <span class="nb">bool</span><span class="p">,</span>
   <span class="p">...</span>
    <span class="nb">property</span><span class="p">,</span>
    <span class="n">types</span><span class="p">.</span><span class="n">BuiltinFunctionType</span><span class="p">,</span>
    <span class="nf">type</span><span class="p">(</span><span class="bp">Ellipsis</span><span class="p">),</span>
    <span class="nf">type</span><span class="p">(</span><span class="nb">NotImplemented</span><span class="p">),</span>
    <span class="n">types</span><span class="p">.</span><span class="n">FunctionType</span><span class="p">,</span>
    <span class="n">weakref</span><span class="p">.</span><span class="n">ref</span><span class="p">,</span>
<span class="p">):</span>
    <span class="n">d</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">_copy_immutable</span>
<span class="n">t</span> <span class="o">=</span> <span class="nf">getattr</span><span class="p">(</span><span class="n">types</span><span class="p">,</span> <span class="s">"CodeType"</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
<span class="k">if</span> <span class="n">t</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
    <span class="n">d</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">_copy_immutable</span>

<span class="n">d</span><span class="p">[</span><span class="nb">list</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">.</span><span class="n">copy</span>

</code></pre></div></div>
<p>The most common of these pre-defined functions is <code class="language-plaintext highlighter-rouge">_copy_immutable</code>, which simply returns the object. This is the case for most of the objects in the tree, but not for the loggers.</p>

<h3 id="the-solution">The solution</h3>

<p>The solution is to add a new entry for logging.Logger to the <code class="language-plaintext highlighter-rouge">_copy_dispatch</code> dictionary that will return the same object without attempting to copy. This is done by adding the following code to the <code class="language-plaintext highlighter-rouge">__init__.py</code> file of the project:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kn">from</span> <span class="n">copy</span> <span class="kn">import</span> <span class="n">_copy_immutable</span><span class="p">,</span> <span class="n">_deepcopy_dispatch</span>
<span class="kn">import</span> <span class="n">logging</span>
<span class="k">def</span> <span class="nf">logger_copy</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">memo</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span>


<span class="n">copy</span><span class="p">.</span><span class="n">_deepcopy_dispatch</span><span class="p">[</span><span class="n">logging</span><span class="p">.</span><span class="n">Logger</span><span class="p">]</span> <span class="o">=</span> <span class="n">logger_copy</span>
</code></pre></div></div>

<h3 id="the-result">The result</h3>

<p>The result is that the deepcopy function will now ignore the locks and copy the loggers. This is not a problem because, at least in this case, i wanted the loggers to continue to write to the same file.</p>]]></content><author><name>SantosJGND</name><email>dourado.jns@gmail.com</email></author><category term="python" /><category term="development" /><category term="deepcopy" /><summary type="html"><![CDATA[Writting this post about a recent problem i had with deepcopy, and how i solved it.]]></summary></entry><entry><title type="html">Coalescent Theory in Python - Introduction</title><link href="http://localhost:4000/python/genetics/coalescent/theory/introduction/2023/04/01/coalescent-intro.html" rel="alternate" type="text/html" title="Coalescent Theory in Python - Introduction" /><published>2023-04-01T11:23:29+01:00</published><updated>2023-04-01T11:23:29+01:00</updated><id>http://localhost:4000/python/genetics/coalescent/theory/introduction/2023/04/01/coalescent-intro</id><content type="html" xml:base="http://localhost:4000/python/genetics/coalescent/theory/introduction/2023/04/01/coalescent-intro.html"><![CDATA[<p>This week i had no particular magic happen at work, so I decided to begin transitioning some material i have previosuly hosted in jupyter notebooks to this blog. I will be posting a series of posts on the coalescent theory, which is a branch of probability theory that is used in population genetics. I wrote them while taking classes on the subject under <a href="http://jjensenlab.org/">Dr. Jeffrey Jensen</a>.</p>

<p>The series was motivated by wanting to combine two things i am interested in: genetics and programming, particularly python. While the package <a href="https://msprime.readthedocs.io/en/stable/">msprime</a> is a great tool for simulating genetic data, I did not encounter python modules for the more basic aspects of coalescent theory. This repository attempted to fill that gap, and provide a reference for myself.</p>

<ul>
  <li>In case that reference does exist, i figured it was still good practice, but please let me know.</li>
</ul>

<p>Before we get into it though, some background on the coalescent theory. Feel free to skip to the next post if you are already familiar with the subject.</p>

<h3 id="short-introduction-to-coalescent-theory">Short introduction to coalescent theory</h3>

<p>Coalescent theory is a branch of probability theory that is used in population genetics. It is used to calculate the probability of a given genealogy, given a set of parameters. Inversely, and more importantly, it can be used to infer important parameters of a population, such as the population size, the mutation rate, and the recombination rate, for a given genealogy. Methods of inference can be analytical, using math, or numerical, using simulations.</p>

<p>Some definitions.</p>

<h4 id="genes">Genes</h4>

<p>In the context of coalescent theory, we think of genealogy from the perspective of a single gene.</p>

<p>Genes are the units of inheritance. They are the sequences of DNA that are passed from parent to offspring. Alleles are the different versions of a gene. For example, the gene for eye color can have two alleles, one for blue eyes, and one for brown eyes.</p>

<h4 id="the-genealogy-of-a-population">The Genealogy of a population</h4>

<p>The genealogy of a population is a tree that describes the ancestry of a population. Each node in the tree represents a single gene, the root of the tree represents the most recent common ancestor of the population. The leaves of the tree represent the genes in the current population, e.g.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>         1
      /     \
     2       3
    / \     / \
   4   5   6   7
  / \ / \ / \ / \
 8  9 10 11 12 13 14
</code></pre></div></div>

<p>One thing to consider going forward is that a tree may not include all present genes, and thus not all ancestors. It then consists of all common ancestors of a subset of modern genes up to the root, e.g.:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>         1
      /    \
     x      3
    / \    / \
   x   x   x   x
  / \ / \ / \ / \
 8  x x x  12 x  14


           1
        /    \
       /      3
      /      / \
     8      12 14
</code></pre></div></div>

<h4 id="the-coalescent">The coalescent</h4>

<p>The coalescent is the process by which two genes in a population merge into a single gene. Looking at the tree above you will notice that this is only possible going from the leaves to the root. This is an important concept to keep in mind: in coalescent theory, we are going backwards in time, from the present to the past.</p>

<p>With this in mind, we find that the probability of a coalescent event occuring in a given generation is given by $\frac{1}{2Ne}$, where $ Ne $ eis the population size.</p>

<h4 id="mutation">Mutation</h4>

<p>Mutation is the process by which a new allele is introduced into a population. The rate of new mutations is the probability of such an event, usually calculated by genereration. In the context of coalescent theory, we think of mutations as occuring against the tree above, such that as we traverse the tree (from the bottom up), the probability of a mutation occuring is given by the mutation rate, $\mu$, times the length of a branch in generations.</p>

<h3 id="the-coalescent-process">The coalescent process</h3>

<p>Putting the above together, as we move up the tree one of two things can happen: a coalescent event, or a mutation event. In either case our state, the number of alleles in the case of a coalescent event, or the number of alleles plus the number of mutations in the case of a mutation event, changes.</p>

<p>The coalescent process is thus a stochastic process that describes the evolution of a population of individuals according to the following rules:</p>

<ol>
  <li>A coalescent event occurs between identical alleles with probability $\frac{1}{2Ne}$, where $Ne$ is the population size.</li>
  <li>A mutation event occurs with probability $\mu2Ne$, where $Ne$ is the population size.</li>
</ol>

<p>The coalescent process is a Markov chain, which means that the probability of a given state depends only on the previous state. This is important because it allows us to calculate the probability of a given genealogy, given a set of parameters. This is done by calculating the probability of the genealogy, given the previous state, and multiplying it by the probability of the previous state, given the previous previous state, and so on, until we reach the root of the tree.</p>]]></content><author><name>SantosJGND</name><email>dourado.jns@gmail.com</email></author><category term="python" /><category term="genetics" /><category term="coalescent" /><category term="theory" /><category term="introduction" /><summary type="html"><![CDATA[This week i had no particular magic happen at work, so I decided to begin transitioning some material i have previosuly hosted in jupyter notebooks to this blog. I will be posting a series of posts on the coalescent theory, which is a branch of probability theory that is used in population genetics. I wrote them while taking classes on the subject under Dr. Jeffrey Jensen.]]></summary></entry><entry><title type="html">Unit testing Paramiko</title><link href="http://localhost:4000/python/unit-tests/paramiko/2023/03/25/paramiko-tests.html" rel="alternate" type="text/html" title="Unit testing Paramiko" /><published>2023-03-25T23:34:26+00:00</published><updated>2023-03-25T23:34:26+00:00</updated><id>http://localhost:4000/python/unit-tests/paramiko/2023/03/25/paramiko-tests</id><content type="html" xml:base="http://localhost:4000/python/unit-tests/paramiko/2023/03/25/paramiko-tests.html"><![CDATA[<p>This post came about while writting unit tests for a project that uses <a href="https://www.paramiko.org/">Paramiko</a>, a python library for running in-python ssh commands. For context, in this project a user can upload a file to a server, and the server will run a script on the file. The script is run on the server, not on the user’s computer. Communication between the user and the server, i.e. running commands on the server, uploading and downloading files, is done through ssh using paramiko.</p>

<p>For this purpose i created a context manager responsible for establishing, and closing, the connection to the server. This worked as follows:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">ConnectorParamiko</span><span class="p">(</span><span class="n">Connector</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">config_file</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="nf">super</span><span class="p">().</span><span class="nf">__init__</span><span class="p">()</span>
        <span class="n">self</span><span class="p">.</span><span class="nf">prep_input</span><span class="p">(</span><span class="n">config_file</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="nf">connect</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">connect</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>

        <span class="n">paramiko_rsa_key</span> <span class="o">=</span> <span class="n">paramiko</span><span class="p">.</span><span class="n">RSAKey</span><span class="p">.</span><span class="nf">from_private_key_file</span><span class="p">(</span>
            <span class="n">self</span><span class="p">.</span><span class="n">rsa_key_path</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">rsa_key</span> <span class="o">=</span> <span class="n">paramiko_rsa_key</span>

        <span class="n">self</span><span class="p">.</span><span class="n">conn</span> <span class="o">=</span> <span class="n">paramiko</span><span class="p">.</span><span class="nc">SSHClient</span><span class="p">()</span>
        <span class="n">self</span><span class="p">.</span><span class="n">conn</span><span class="p">.</span><span class="nf">set_missing_host_key_policy</span><span class="p">(</span><span class="n">paramiko</span><span class="p">.</span><span class="nc">AutoAddPolicy</span><span class="p">())</span>
        <span class="n">self</span><span class="p">.</span><span class="nf">test_connection</span><span class="p">()</span>


    <span class="k">def</span> <span class="nf">__enter__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>

        <span class="k">try</span><span class="p">:</span>

            <span class="n">self</span><span class="p">.</span><span class="n">conn</span><span class="p">.</span><span class="nf">connect</span><span class="p">(</span>
                <span class="n">hostname</span><span class="o">=</span><span class="sa">f</span><span class="s">"</span><span class="si">{</span><span class="n">self</span><span class="p">.</span><span class="n">ip_address</span><span class="si">}</span><span class="s">"</span><span class="p">,</span>
                <span class="n">username</span><span class="o">=</span><span class="sa">f</span><span class="s">"</span><span class="si">{</span><span class="n">self</span><span class="p">.</span><span class="n">username</span><span class="si">}</span><span class="s">"</span><span class="p">,</span>
                <span class="n">pkey</span><span class="o">=</span><span class="n">self</span><span class="p">.</span><span class="n">rsa_key</span>
            <span class="p">)</span>

        <span class="k">except</span> <span class="n">paramiko</span><span class="p">.</span><span class="n">ssh_exception</span><span class="p">.</span><span class="n">SSHException</span> <span class="k">as</span> <span class="n">error</span><span class="p">:</span>
            <span class="nf">print</span><span class="p">(</span><span class="s">"SSH connection error"</span><span class="p">)</span>
            <span class="n">sys</span><span class="p">.</span><span class="nf">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">self</span>

    <span class="k">def</span> <span class="nf">__exit__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">exc_type</span><span class="p">,</span> <span class="n">exc_val</span><span class="p">,</span> <span class="n">exc_tb</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">conn</span><span class="p">.</span><span class="nf">close</span><span class="p">()</span></code></pre></figure>

<p>In the code above, <code class="language-plaintext highlighter-rouge">self.conn</code> is an instance of <code class="language-plaintext highlighter-rouge">paramiko.SSHClient()</code>. The <code class="language-plaintext highlighter-rouge">__enter__</code> method establishes the connection, and the <code class="language-plaintext highlighter-rouge">__exit__</code> method closes it.</p>

<p>Other methods of <code class="language-plaintext highlighter-rouge">ConnectorParamiko</code> depend on Paramiko methods, such as <code class="language-plaintext highlighter-rouge">self.conn.exec_command()</code>, <code class="language-plaintext highlighter-rouge">self.conn.put()</code>, <code class="language-plaintext highlighter-rouge">self.conn.get()</code>, etc.</p>

<p>And this works fine, until you try to write unit tests for it. First you need to mock the <code class="language-plaintext highlighter-rouge">paramiko.SSHClient()</code> object, and you need to mock the methods that depend on it. And you need a way to mock a remote server. The package <a href="https://pypi.org/project/MockSSH/"><code class="language-plaintext highlighter-rouge">MockSSH</code></a>, built on top of <code class="language-plaintext highlighter-rouge">paramiko</code>, has been created for this exact purpose. It allows you to create a mock server, and to mock the methods of <code class="language-plaintext highlighter-rouge">paramiko.SSHClient()</code>. But <code class="language-plaintext highlighter-rouge">MockSSH</code> is a context manager, and so is <code class="language-plaintext highlighter-rouge">ConnectorParamiko</code>, so how do you use them together to test the methods of <code class="language-plaintext highlighter-rouge">ConnectorParamiko</code>?</p>

<p>After some research, I found a solution that works. It turns out you can have nested context managers. So i could yield the <code class="language-plaintext highlighter-rouge">MockSSH</code> context manager from the <code class="language-plaintext highlighter-rouge">ConnectorParamiko</code> context manager, and then use the <code class="language-plaintext highlighter-rouge">MockSSH</code> context manager to mock the methods of <code class="language-plaintext highlighter-rouge">paramiko.SSHClient()</code>:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python">    <span class="k">def</span> <span class="nf">connect</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="s">"""
        create local ssh mock server"""</span>
        <span class="n">users</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s">"test-user"</span><span class="p">:</span> <span class="s">"/home/bioinf/.ssh/id_rsa"</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="n">self</span><span class="p">.</span><span class="n">server</span> <span class="o">=</span> <span class="n">mockssh</span><span class="p">.</span><span class="nc">Server</span><span class="p">(</span><span class="n">users</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__enter__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">server</span><span class="p">.</span><span class="nf">__enter__</span><span class="p">()</span>
        <span class="k">with</span> <span class="n">self</span><span class="p">.</span><span class="n">server</span> <span class="k">as</span> <span class="n">s</span><span class="p">:</span>
            <span class="n">self</span><span class="p">.</span><span class="n">conn</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="nf">client</span><span class="p">(</span><span class="s">"test-user"</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">self</span>

    <span class="k">def</span> <span class="nf">__exit__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">exc_type</span><span class="p">,</span> <span class="n">exc_value</span><span class="p">,</span> <span class="n">traceback</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">server</span><span class="p">.</span><span class="nf">__exit__</span><span class="p">(</span><span class="n">exc_type</span><span class="p">,</span> <span class="n">exc_value</span><span class="p">,</span> <span class="n">traceback</span><span class="p">)</span></code></pre></figure>

<p>The <code class="language-plaintext highlighter-rouge">connect</code> method creates a mock server, and the <code class="language-plaintext highlighter-rouge">__enter__</code> method yields the mock server context manager. The <code class="language-plaintext highlighter-rouge">__exit__</code> method closes the mock server. The <code class="language-plaintext highlighter-rouge">__enter__</code> method also yields the <code class="language-plaintext highlighter-rouge">paramiko.SSHClient()</code> context manager, and returns the <code class="language-plaintext highlighter-rouge">ConnectorParamiko</code> object. This way, the <code class="language-plaintext highlighter-rouge">ConnectorParamiko</code> object can be used to mock the methods of <code class="language-plaintext highlighter-rouge">paramiko.SSHClient()</code>.</p>

<p>That’s it. Forgive me if this was obvious, but I couldn’t find a solution anywhere else. I hope this helps someone.</p>]]></content><author><name>SantosJGND</name><email>dourado.jns@gmail.com</email></author><category term="python" /><category term="unit-tests" /><category term="paramiko" /><summary type="html"><![CDATA[This post came about while writting unit tests for a project that uses Paramiko, a python library for running in-python ssh commands. For context, in this project a user can upload a file to a server, and the server will run a script on the file. The script is run on the server, not on the user’s computer. Communication between the user and the server, i.e. running commands on the server, uploading and downloading files, is done through ssh using paramiko.]]></summary></entry></feed>
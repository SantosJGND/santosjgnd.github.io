<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-06-17T14:47:19+01:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Research Log</title><subtitle>A technical account of my research path where I expose the problems I faced and how I solved them, with some detours into interesting tangents along the way.
</subtitle><author><name>SantosJGND</name><email>dourado.jns@gmail.com</email></author><entry><title type="html">Coalescent Theory in Python - Introduction</title><link href="http://localhost:4000/python/genetics/coalescent/theory/introduction/2023/04/01/coalescent-intro.html" rel="alternate" type="text/html" title="Coalescent Theory in Python - Introduction" /><published>2023-04-01T11:23:29+01:00</published><updated>2023-04-01T11:23:29+01:00</updated><id>http://localhost:4000/python/genetics/coalescent/theory/introduction/2023/04/01/coalescent-intro</id><content type="html" xml:base="http://localhost:4000/python/genetics/coalescent/theory/introduction/2023/04/01/coalescent-intro.html"><![CDATA[<p>This week i had no particular magic happen at work, so I decided to begin transitioning some material i have previosuly hosted in jupyter notebooks to this blog. I will be posting a series of posts on the coalescent theory, which is a branch of probability theory that is used in population genetics. I wrote them while taking classes on the subject under <a href="http://jjensenlab.org/">Dr. Jeffrey Jensen</a>.</p>

<p>The series was motivated by wanting to combine two things i am interested in: genetics and programming, particularly python. While the package <a href="https://msprime.readthedocs.io/en/stable/">msprime</a> is a great tool for simulating genetic data, I did not encounter python modules for the more basic aspects of coalescent theory. This repository attempted to fill that gap, and provide a reference for myself.</p>

<ul>
  <li>In case that reference does exist, i figured it was still good practice, but please let me know.</li>
</ul>

<p>Before we get into it though, some background on the coalescent theory. Feel free to skip to the next post if you are already familiar with the subject.</p>

<h3 id="short-introduction-to-coalescent-theory">Short introduction to coalescent theory</h3>

<p>Coalescent theory is a branch of probability theory that is used in population genetics. It is used to calculate the probability of a given genealogy, given a set of parameters. Inversely, and more importantly, it can be used to infer important parameters of a population, such as the population size, the mutation rate, and the recombination rate, for a given genealogy. Methods of inference can be analytical, using math, or numerical, using simulations.</p>

<p>Some definitions.</p>

<h4 id="genes">Genes</h4>

<p>In the context of coalescent theory, we think of genealogy from the perspective of a single gene.</p>

<p>Genes are the units of inheritance. They are the sequences of DNA that are passed from parent to offspring. Alleles are the different versions of a gene. For example, the gene for eye color can have two alleles, one for blue eyes, and one for brown eyes.</p>

<h4 id="the-genealogy-of-a-population">The Genealogy of a population</h4>

<p>The genealogy of a population is a tree that describes the ancestry of a population. Each node in the tree represents a single gene, the root of the tree represents the most recent common ancestor of the population. The leaves of the tree represent the genes in the current population, e.g.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>         1
      /     \
     2       3
    / \     / \
   4   5   6   7
  / \ / \ / \ / \
 8  9 10 11 12 13 14
</code></pre></div></div>

<p>One thing to consider going forward is that a tree may not include all present genes, and thus not all ancestors. It then consists of all common ancestors of a subset of modern genes up to the root, e.g.:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>         1
      /    \
     x      3
    / \    / \
   x   x   x   x
  / \ / \ / \ / \
 8  x x x  12 x  14


           1
        /    \
       /      3
      /      / \
     8      12 14
</code></pre></div></div>

<h4 id="the-coalescent">The coalescent</h4>

<p>The coalescent is the process by which two genes in a population merge into a single gene. Looking at the tree above you will notice that this is only possible going from the leaves to the root. This is an important concept to keep in mind: in coalescent theory, we are going backwards in time, from the present to the past.</p>

<p>With this in mind, we find that the probability of a coalescent event occuring in a given generation is given by $\frac{1}{2Ne}$, where $ Ne $ eis the population size.</p>

<h4 id="mutation">Mutation</h4>

<p>Mutation is the process by which a new allele is introduced into a population. The rate of new mutations is the probability of such an event, usually calculated by genereration. In the context of coalescent theory, we think of mutations as occuring against the tree above, such that as we traverse the tree (from the bottom up), the probability of a mutation occuring is given by the mutation rate, $\mu$, times the length of a branch in generations.</p>

<h3 id="the-coalescent-process">The coalescent process</h3>

<p>Putting the above together, as we move up the tree one of two things can happen: a coalescent event, or a mutation event. In either case our state, the number of alleles in the case of a coalescent event, or the number of alleles plus the number of mutations in the case of a mutation event, changes.</p>

<p>The coalescent process is thus a stochastic process that describes the evolution of a population of individuals according to the following rules:</p>

<ol>
  <li>A coalescent event occurs between identical alleles with probability $\frac{1}{2Ne}$, where $Ne$ is the population size.</li>
  <li>A mutation event occurs with probability $\mu2Ne$, where $Ne$ is the population size.</li>
</ol>

<p>The coalescent process is a Markov chain, which means that the probability of a given state depends only on the previous state. This is important because it allows us to calculate the probability of a given genealogy, given a set of parameters. This is done by calculating the probability of the genealogy, given the previous state, and multiplying it by the probability of the previous state, given the previous previous state, and so on, until we reach the root of the tree.</p>]]></content><author><name>SantosJGND</name><email>dourado.jns@gmail.com</email></author><category term="python" /><category term="genetics" /><category term="coalescent" /><category term="theory" /><category term="introduction" /><summary type="html"><![CDATA[This week i had no particular magic happen at work, so I decided to begin transitioning some material i have previosuly hosted in jupyter notebooks to this blog. I will be posting a series of posts on the coalescent theory, which is a branch of probability theory that is used in population genetics. I wrote them while taking classes on the subject under Dr. Jeffrey Jensen.]]></summary></entry><entry><title type="html">Unit testing Paramiko</title><link href="http://localhost:4000/python/unit-tests/paramiko/2023/03/25/paramiko-tests.html" rel="alternate" type="text/html" title="Unit testing Paramiko" /><published>2023-03-25T23:34:26+00:00</published><updated>2023-03-25T23:34:26+00:00</updated><id>http://localhost:4000/python/unit-tests/paramiko/2023/03/25/paramiko-tests</id><content type="html" xml:base="http://localhost:4000/python/unit-tests/paramiko/2023/03/25/paramiko-tests.html"><![CDATA[<p>This post came about while writting unit tests for a project that uses <a href="https://www.paramiko.org/">Paramiko</a>, a python library for running in-python ssh commands. For context, in this project a user can upload a file to a server, and the server will run a script on the file. The script is run on the server, not on the user’s computer. Communication between the user and the server, i.e. running commands on the server, uploading and downloading files, is done through ssh using paramiko.</p>

<p>For this purpose i created a context manager responsible for establishing, and closing, the connection to the server. This worked as follows:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">ConnectorParamiko</span><span class="p">(</span><span class="n">Connector</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">config_file</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="nf">super</span><span class="p">().</span><span class="nf">__init__</span><span class="p">()</span>
        <span class="n">self</span><span class="p">.</span><span class="nf">prep_input</span><span class="p">(</span><span class="n">config_file</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="nf">connect</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">connect</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>

        <span class="n">paramiko_rsa_key</span> <span class="o">=</span> <span class="n">paramiko</span><span class="p">.</span><span class="n">RSAKey</span><span class="p">.</span><span class="nf">from_private_key_file</span><span class="p">(</span>
            <span class="n">self</span><span class="p">.</span><span class="n">rsa_key_path</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">rsa_key</span> <span class="o">=</span> <span class="n">paramiko_rsa_key</span>

        <span class="n">self</span><span class="p">.</span><span class="n">conn</span> <span class="o">=</span> <span class="n">paramiko</span><span class="p">.</span><span class="nc">SSHClient</span><span class="p">()</span>
        <span class="n">self</span><span class="p">.</span><span class="n">conn</span><span class="p">.</span><span class="nf">set_missing_host_key_policy</span><span class="p">(</span><span class="n">paramiko</span><span class="p">.</span><span class="nc">AutoAddPolicy</span><span class="p">())</span>
        <span class="n">self</span><span class="p">.</span><span class="nf">test_connection</span><span class="p">()</span>


    <span class="k">def</span> <span class="nf">__enter__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>

        <span class="k">try</span><span class="p">:</span>

            <span class="n">self</span><span class="p">.</span><span class="n">conn</span><span class="p">.</span><span class="nf">connect</span><span class="p">(</span>
                <span class="n">hostname</span><span class="o">=</span><span class="sa">f</span><span class="s">"</span><span class="si">{</span><span class="n">self</span><span class="p">.</span><span class="n">ip_address</span><span class="si">}</span><span class="s">"</span><span class="p">,</span>
                <span class="n">username</span><span class="o">=</span><span class="sa">f</span><span class="s">"</span><span class="si">{</span><span class="n">self</span><span class="p">.</span><span class="n">username</span><span class="si">}</span><span class="s">"</span><span class="p">,</span>
                <span class="n">pkey</span><span class="o">=</span><span class="n">self</span><span class="p">.</span><span class="n">rsa_key</span>
            <span class="p">)</span>

        <span class="k">except</span> <span class="n">paramiko</span><span class="p">.</span><span class="n">ssh_exception</span><span class="p">.</span><span class="n">SSHException</span> <span class="k">as</span> <span class="n">error</span><span class="p">:</span>
            <span class="nf">print</span><span class="p">(</span><span class="s">"SSH connection error"</span><span class="p">)</span>
            <span class="n">sys</span><span class="p">.</span><span class="nf">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">self</span>

    <span class="k">def</span> <span class="nf">__exit__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">exc_type</span><span class="p">,</span> <span class="n">exc_val</span><span class="p">,</span> <span class="n">exc_tb</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">conn</span><span class="p">.</span><span class="nf">close</span><span class="p">()</span></code></pre></figure>

<p>In the code above, <code class="language-plaintext highlighter-rouge">self.conn</code> is an instance of <code class="language-plaintext highlighter-rouge">paramiko.SSHClient()</code>. The <code class="language-plaintext highlighter-rouge">__enter__</code> method establishes the connection, and the <code class="language-plaintext highlighter-rouge">__exit__</code> method closes it.</p>

<p>Other methods of <code class="language-plaintext highlighter-rouge">ConnectorParamiko</code> depend on Paramiko methods, such as <code class="language-plaintext highlighter-rouge">self.conn.exec_command()</code>, <code class="language-plaintext highlighter-rouge">self.conn.put()</code>, <code class="language-plaintext highlighter-rouge">self.conn.get()</code>, etc.</p>

<p>And this works fine, until you try to write unit tests for it. First you need to mock the <code class="language-plaintext highlighter-rouge">paramiko.SSHClient()</code> object, and you need to mock the methods that depend on it. And you need a way to mock a remote server. The package <a href="https://pypi.org/project/MockSSH/"><code class="language-plaintext highlighter-rouge">MockSSH</code></a>, built on top of <code class="language-plaintext highlighter-rouge">paramiko</code>, has been created for this exact purpose. It allows you to create a mock server, and to mock the methods of <code class="language-plaintext highlighter-rouge">paramiko.SSHClient()</code>. But <code class="language-plaintext highlighter-rouge">MockSSH</code> is a context manager, and so is <code class="language-plaintext highlighter-rouge">ConnectorParamiko</code>, so how do you use them together to test the methods of <code class="language-plaintext highlighter-rouge">ConnectorParamiko</code>?</p>

<p>After some research, I found a solution that works. It turns out you can have nested context managers. So i could yield the <code class="language-plaintext highlighter-rouge">MockSSH</code> context manager from the <code class="language-plaintext highlighter-rouge">ConnectorParamiko</code> context manager, and then use the <code class="language-plaintext highlighter-rouge">MockSSH</code> context manager to mock the methods of <code class="language-plaintext highlighter-rouge">paramiko.SSHClient()</code>:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python">    <span class="k">def</span> <span class="nf">connect</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="s">"""
        create local ssh mock server"""</span>
        <span class="n">users</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s">"test-user"</span><span class="p">:</span> <span class="s">"/home/bioinf/.ssh/id_rsa"</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="n">self</span><span class="p">.</span><span class="n">server</span> <span class="o">=</span> <span class="n">mockssh</span><span class="p">.</span><span class="nc">Server</span><span class="p">(</span><span class="n">users</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__enter__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">server</span><span class="p">.</span><span class="nf">__enter__</span><span class="p">()</span>
        <span class="k">with</span> <span class="n">self</span><span class="p">.</span><span class="n">server</span> <span class="k">as</span> <span class="n">s</span><span class="p">:</span>
            <span class="n">self</span><span class="p">.</span><span class="n">conn</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="nf">client</span><span class="p">(</span><span class="s">"test-user"</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">self</span>

    <span class="k">def</span> <span class="nf">__exit__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">exc_type</span><span class="p">,</span> <span class="n">exc_value</span><span class="p">,</span> <span class="n">traceback</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">server</span><span class="p">.</span><span class="nf">__exit__</span><span class="p">(</span><span class="n">exc_type</span><span class="p">,</span> <span class="n">exc_value</span><span class="p">,</span> <span class="n">traceback</span><span class="p">)</span></code></pre></figure>

<p>The <code class="language-plaintext highlighter-rouge">connect</code> method creates a mock server, and the <code class="language-plaintext highlighter-rouge">__enter__</code> method yields the mock server context manager. The <code class="language-plaintext highlighter-rouge">__exit__</code> method closes the mock server. The <code class="language-plaintext highlighter-rouge">__enter__</code> method also yields the <code class="language-plaintext highlighter-rouge">paramiko.SSHClient()</code> context manager, and returns the <code class="language-plaintext highlighter-rouge">ConnectorParamiko</code> object. This way, the <code class="language-plaintext highlighter-rouge">ConnectorParamiko</code> object can be used to mock the methods of <code class="language-plaintext highlighter-rouge">paramiko.SSHClient()</code>.</p>

<p>That’s it. Forgive me if this was obvious, but I couldn’t find a solution anywhere else. I hope this helps someone.</p>]]></content><author><name>SantosJGND</name><email>dourado.jns@gmail.com</email></author><category term="python" /><category term="unit-tests" /><category term="paramiko" /><summary type="html"><![CDATA[This post came about while writting unit tests for a project that uses Paramiko, a python library for running in-python ssh commands. For context, in this project a user can upload a file to a server, and the server will run a script on the file. The script is run on the server, not on the user’s computer. Communication between the user and the server, i.e. running commands on the server, uploading and downloading files, is done through ssh using paramiko.]]></summary></entry></feed>